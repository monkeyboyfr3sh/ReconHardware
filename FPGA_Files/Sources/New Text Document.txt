        //In a multiply state, dataSet and filterSet should be filled with needed values
        else if(MULTIst) begin
            mCount = mCount + 1;
        
            //Completed all multiplications
            if(Mloopcnt>=`KERNELSIZE) begin
            
                //Shift values in the data register to let next kernelsize be read in
                for(datapointer = 0; datapointer < (`KERNELSIZE*`KERNELSIZE-`KERNELSIZE); datapointer = datapointer+1)begin
                    dataSet[datapointer] = dataSet[datapointer+`KERNELSIZE];
                end
                
                //Indicate the next values need to be read in when reading
                dataSetFilled = 0;
                MULTIPLY_START = 0;
                Mloopcnt = 0;
                MULTIst = 0;
                ADDst = 1;
            end
            
            //Still have data to process
            else begin
            
                //Loop through each row at Mloopcnt column
                for( MPi = 0; MPi < `KERNELSIZE; MPi=MPi+1 )begin
                   MULTIPLIER_INPUT[MPi*`bitLength+:`bitLength] = dataSet[MPi+(Mloopcnt*`KERNELSIZE)];
                   MULTIPLICAND_INPUT[MPi*`bitLength+:`bitLength] = filterSet[MPi+(Mloopcnt*`KERNELSIZE)];
                   MULTIPLY_START[MPi] = 1;
                end
                
                Mloopcnt = Mloopcnt + 1;
            end
        end
        //End of MULTIst

        //In an Add state, should add all values once data set has been completely computed.
        else if(ADDst)begin
            aCount = aCount + 1;
            //Signal for matrix device to add the multiply registers
            if(!cReady) begin
                FINALADD = 1;              
            end
            
            //Got the signal that the convolution is completed
            else begin
                cCount = cCount + 1;//Track the number of convolutions completed                
                
                //Reset all state flags
                ADDst = 0;
                RDst = 0;
                MULTIst = 0;
                FINALADD = 0;
                
                //Need to output cSum to DMA and signal for transaction
                m_axis_data = cSum;
                
                m_axis_valid = 1;
                m_axis_keep = 4'hf;
                ip_reset_out = 1;//Reset the matrix deivce registers
                current_x = current_x+1;//Update position on image map
                
                //If need to update position due to end of row
                if(current_x+`KERNELSIZE-1 >= image_width)begin
                
                    //Trigger for data reset with newline
                    newline = 1;
                    current_x = 0;
                    current_y = current_y+1;
                end
                
                if(current_y+`KERNELSIZE-1 >= image_height)begin
                    m_axis_last = 1;
                end   
            end
        end
    end//End of ADDst