<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item value="false" key="isRegEx"/>
		<item value="--- Entering main() ---" key="selection"/>
		<item value="false" key="casesensitive"/>
		<item value="false" key="incremental"/>
		<item value="true" key="wrap"/>
		<item value="false" key="wholeword"/>
		<list key="findhistory">
			<item value="--- Entering main() ---"/>
			<item value="/******************************************************************************&#x0A;*&#x0A;* Copyright (C) 2010 - 2019 Xilinx, Inc.  All rights reserved.&#x0A;*&#x0A;* Permission is hereby granted, free of charge, to any person obtaining a copy&#x0A;* of this software and associated documentation files (the &quot;Software&quot;), to deal&#x0A;* in the Software without restriction, including without limitation the rights&#x0A;* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell&#x0A;* copies of the Software, and to permit persons to whom the Software is&#x0A;* furnished to do so, subject to the following conditions:&#x0A;*&#x0A;* The above copyright notice and this permission notice shall be included in&#x0A;* all copies or substantial portions of the Software.&#x0A;*&#x0A;* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR&#x0A;* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,&#x0A;* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL&#x0A;* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER&#x0A;* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,&#x0A;* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN&#x0A;* THE SOFTWARE.&#x0A;*&#x0A;* &#x0A;*&#x0A;******************************************************************************/&#x0A;/*****************************************************************************/&#x0A;/**&#x0A; *&#x0A; * @file xaxidma_example_sg_poll.c&#x0A; *&#x0A; * This file demonstrates how to use the xaxidma driver on the Xilinx AXI&#x0A; * DMA core (AXIDMA) to transfer packets in polling mode when the AXIDMA&#x0A; * core is configured in Scatter Gather Mode.&#x0A; *&#x0A; * This code assumes a loopback hardware widget is connected to the AXI DMA&#x0A; * core for data packet loopback.&#x0A; *&#x0A; * To see the debug print, you need a Uart16550 or uartlite in your system,&#x0A; * and please set &quot;-DDEBUG&quot; in your compiler options. You need to rebuild your&#x0A; * software executable.&#x0A; *&#x0A; * Make sure that MEMORY_BASE is defined properly as per the HW system. The&#x0A; * h/w system built in Area mode has a maximum DDR memory limit of 64MB. In&#x0A; * throughput mode, it is 512MB.  These limits are need to ensured for&#x0A; * proper operation of this code.&#x0A; *&#x0A; *&#x0A; * &lt;pre&gt;&#x0A; * MODIFICATION HISTORY:&#x0A; *&#x0A; * Ver   Who  Date     Changes&#x0A; * ----- ---- -------- -------------------------------------------------------&#x0A; * 1.00a jz   05/17/10 First release&#x0A; * 2.00a jz   08/10/10 Second release, added in xaxidma_g.c, xaxidma_sinit.c,&#x0A; *                     updated tcl file, added xaxidma_porting_guide.h, removed&#x0A; *                     workaround for endianness&#x0A; * 4.00a rkv  02/22/11 Name of the file has been changed for naming consistency&#x0A; *       &#x09;       &#x09;   Added interrupt support for ARM.&#x0A; * 5.00a srt  03/05/12 Added Flushing and Invalidation of Caches to fix CRs&#x0A; *&#x09;&#x09;       &#x09;&#x09;   648103, 648701.&#x0A; *&#x09;&#x09;       &#x09;&#x09;   Added V7 DDR Base Address to fix CR 649405.&#x0A; * 6.00a srt  03/27/12 Changed API calls to support MCDMA driver.&#x0A; * 7.00a srt  06/18/12 API calls are reverted back for backward compatibility.&#x0A; * 7.01a srt  11/02/12 Buffer sizes (Tx and Rx) are modified to meet maximum&#x0A; *&#x09;&#x09;       DDR memory limit of the h/w system built with Area mode&#x0A; * 7.02a srt  03/01/13 Updated DDR base address for IPI designs (CR 703656).&#x0A; * 9.1   adk  01/07/16 Updated DDR base address for Ultrascale (CR 799532) and&#x0A; *&#x09;&#x09;       removed the defines for S6/V6.&#x0A; * 9.2   vak  15/04/16 Fixed compilation warnings in th example&#x0A; * 9.3   ms   01/23/17 Modified xil_printf statement in main function to&#x0A; *                     ensure that &quot;Successfully ran&quot; and &quot;Failed&quot; strings are&#x0A; *                     available in all examples. This is a fix for CR-965028.&#x0A; * 9.9   rsp  01/21/19 Fix use of #elif check in deriving DDR_BASE_ADDR.&#x0A; * 9.10  rsp  09/17/19 Fix cache maintenance ops for source and dest buffer.&#x0A; * &lt;/pre&gt;&#x0A; *&#x0A; * ***************************************************************************&#x0A; */&#x0A;/***************************** Include Files *********************************/&#x0A;#include &quot;xaxidma.h&quot;&#x0A;#include &quot;xparameters.h&quot;&#x0A;#include &quot;xdebug.h&quot;&#x0A;&#x0A;#ifdef __aarch64__&#x0A;#include &quot;xil_mmu.h&quot;&#x0A;#endif&#x0A;&#x0A;#if defined(XPAR_UARTNS550_0_BASEADDR)&#x0A;#include &quot;xuartns550_l.h&quot;       /* to use uartns550 */&#x0A;#endif&#x0A;&#x0A;#if (!defined(DEBUG))&#x0A;extern void xil_printf(const char *format, ...);&#x0A;#endif&#x0A;&#x0A;/******************** Constant Definitions **********************************/&#x0A;&#x0A;/*&#x0A; * Device hardware build related constants.&#x0A; */&#x0A;&#x0A;#define DMA_DEV_ID&#x09;&#x09;XPAR_AXIDMA_0_DEVICE_ID&#x0A;&#x0A;#ifdef XPAR_AXI_7SDDR_0_S_AXI_BASEADDR&#x0A;#define DDR_BASE_ADDR&#x09;&#x09;XPAR_AXI_7SDDR_0_S_AXI_BASEADDR&#x0A;#elif defined (XPAR_MIG7SERIES_0_BASEADDR)&#x0A;#define DDR_BASE_ADDR&#x09;XPAR_MIG7SERIES_0_BASEADDR&#x0A;#elif defined (XPAR_MIG_0_BASEADDR)&#x0A;#define DDR_BASE_ADDR&#x09;XPAR_MIG_0_BASEADDR&#x0A;#elif defined (XPAR_PSU_DDR_0_S_AXI_BASEADDR)&#x0A;#define DDR_BASE_ADDR&#x09;XPAR_PSU_DDR_0_S_AXI_BASEADDR&#x0A;#endif&#x0A;&#x0A;#ifndef DDR_BASE_ADDR&#x0A;#warning CHECK FOR THE VALID DDR ADDRESS IN XPARAMETERS.H, \&#x0A;&#x09;&#x09;&#x09;DEFAULT SET TO 0x01000000&#x0A;#define MEM_BASE_ADDR&#x09;&#x09;0x01000000&#x0A;#else&#x0A;#define MEM_BASE_ADDR&#x09;&#x09;(DDR_BASE_ADDR + 0x1000000)&#x0A;#endif&#x0A;&#x0A;#define TX_BD_SPACE_BASE&#x09;(MEM_BASE_ADDR)&#x0A;#define TX_BD_SPACE_HIGH&#x09;(MEM_BASE_ADDR + 0x00000FFF)&#x0A;#define RX_BD_SPACE_BASE&#x09;(MEM_BASE_ADDR + 0x00001000)&#x0A;#define RX_BD_SPACE_HIGH&#x09;(MEM_BASE_ADDR + 0x00001FFF)&#x0A;#define TX_BUFFER_BASE&#x09;&#x09;(MEM_BASE_ADDR + 0x00100000)&#x0A;#define RX_BUFFER_BASE&#x09;&#x09;(MEM_BASE_ADDR + 0x00300000)&#x0A;#define RX_BUFFER_HIGH&#x09;&#x09;(MEM_BASE_ADDR + 0x004FFFFF)&#x0A;&#x0A;&#x0A;#define MAX_PKT_LEN&#x09;&#x09;0x20&#x0A;#define MARK_UNCACHEABLE        0x701&#x0A;&#x0A;#define TEST_START_VALUE&#x09;0xC&#x0A;&#x0A;/**************************** Type Definitions *******************************/&#x0A;&#x0A;&#x0A;/***************** Macros (Inline Functions) Definitions *********************/&#x0A;&#x0A;&#x0A;/************************** Function Prototypes ******************************/&#x0A;#if defined(XPAR_UARTNS550_0_BASEADDR)&#x0A;static void Uart550_Setup(void);&#x0A;#endif&#x0A;&#x0A;static int RxSetup(XAxiDma * AxiDmaInstPtr);&#x0A;static int TxSetup(XAxiDma * AxiDmaInstPtr);&#x0A;static int SendPacket(XAxiDma * AxiDmaInstPtr);&#x0A;static int CheckData(void);&#x0A;static int CheckDmaResult(XAxiDma * AxiDmaInstPtr);&#x0A;&#x0A;/************************** Variable Definitions *****************************/&#x0A;/*&#x0A; * Device instance definitions&#x0A; */&#x0A;XAxiDma AxiDma;&#x0A;&#x0A;/*&#x0A; * Buffer for transmit packet. Must be 32-bit aligned to be used by DMA.&#x0A; */&#x0A;u32 *Packet = (u32 *) TX_BUFFER_BASE;&#x0A;&#x0A;/*****************************************************************************/&#x0A;/**&#x0A;*&#x0A;* Main function&#x0A;*&#x0A;* This function is the main entry of the tests on DMA core. It sets up&#x0A;* DMA engine to be ready to receive and send packets, then a packet is&#x0A;* transmitted and will be verified after it is received via the DMA loopback&#x0A;* widget.&#x0A;*&#x0A;* @param&#x09;None&#x0A;*&#x0A;* @return&#x0A;*&#x09;&#x09;- XST_SUCCESS if test passes&#x0A;*&#x09;&#x09;- XST_FAILURE if test fails.&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;int main(void)&#x0A;{&#x0A;&#x09;int Status;&#x0A;&#x09;XAxiDma_Config *Config;&#x0A;&#x0A;#if defined(XPAR_UARTNS550_0_BASEADDR)&#x0A;&#x0A;&#x09;Uart550_Setup();&#x0A;&#x0A;#endif&#x0A;&#x0A;&#x09;xil_printf(&quot;\r\n--- Entering main() --- \r\n&quot;);&#x0A;&#x0A;#ifdef __aarch64__&#x0A;&#x09;Xil_SetTlbAttributes(TX_BD_SPACE_BASE, MARK_UNCACHEABLE);&#x0A;&#x09;Xil_SetTlbAttributes(RX_BD_SPACE_BASE, MARK_UNCACHEABLE);&#x0A;#endif&#x0A;&#x0A;&#x09;Config = XAxiDma_LookupConfig(DMA_DEV_ID);&#x0A;&#x09;if (!Config) {&#x0A;&#x09;&#x09;xil_printf(&quot;No config found for %d\r\n&quot;, DMA_DEV_ID);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Initialize DMA engine */&#x0A;&#x09;Status = XAxiDma_CfgInitialize(&amp;AxiDma, Config);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Initialization failed %d\r\n&quot;, Status);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;if(!XAxiDma_HasSg(&amp;AxiDma)) {&#x0A;&#x09;&#x09;xil_printf(&quot;Device configured as Simple mode \r\n&quot;);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;Status = TxSetup(&amp;AxiDma);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;Status = RxSetup(&amp;AxiDma);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Send a packet */&#x0A;&#x09;Status = SendPacket(&amp;AxiDma);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Check DMA transfer result */&#x0A;&#x09;Status = CheckDmaResult(&amp;AxiDma);&#x0A;&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;AXI DMA SG Polling Example Failed\r\n&quot;);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;xil_printf(&quot;Successfully ran AXI DMA SG Polling Example\r\n&quot;);&#x0A;&#x09;xil_printf(&quot;--- Exiting main() --- \r\n&quot;);&#x0A;&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;&#x0A;#if defined(XPAR_UARTNS550_0_BASEADDR)&#x0A;/*****************************************************************************/&#x0A;/*&#x0A;*&#x0A;* Uart16550 setup routine, need to set baudrate to 9600, and data bits to 8&#x0A;*&#x0A;* @param&#x09;None&#x0A;*&#x0A;* @return&#x09;None&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static void Uart550_Setup(void)&#x0A;{&#x0A;&#x0A;&#x09;/* Set the baudrate to be predictable&#x0A;&#x09; */&#x0A;&#x09;XUartNs550_SetBaud(XPAR_UARTNS550_0_BASEADDR,&#x0A;&#x09;&#x09;&#x09;XPAR_XUARTNS550_CLOCK_HZ, 9600);&#x0A;&#x0A;&#x09;XUartNs550_SetLineControlReg(XPAR_UARTNS550_0_BASEADDR,&#x0A;&#x09;&#x09;&#x09;XUN_LCR_8_DATA_BITS);&#x0A;&#x0A;}&#x0A;#endif&#x0A;&#x0A;/*****************************************************************************/&#x0A;/**&#x0A;*&#x0A;* This function sets up RX channel of the DMA engine to be ready for packet&#x0A;* reception&#x0A;*&#x0A;* @param&#x09;AxiDmaInstPtr is the pointer to the instance of the DMA engine.&#x0A;*&#x0A;* @return&#x09;XST_SUCCESS if the setup is successful, XST_FAILURE otherwise.&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static int RxSetup(XAxiDma * AxiDmaInstPtr)&#x0A;{&#x0A;&#x09;XAxiDma_BdRing *RxRingPtr;&#x0A;&#x09;int Delay = 0;&#x0A;&#x09;int Coalesce = 1;&#x0A;&#x09;int Status;&#x0A;&#x09;XAxiDma_Bd BdTemplate;&#x0A;&#x09;XAxiDma_Bd *BdPtr;&#x0A;&#x09;XAxiDma_Bd *BdCurPtr;&#x0A;&#x09;u32 BdCount;&#x0A;&#x09;u32 FreeBdCount;&#x0A;&#x09;UINTPTR RxBufferPtr;&#x0A;&#x09;int Index;&#x0A;&#x0A;&#x09;RxRingPtr = XAxiDma_GetRxRing(&amp;AxiDma);&#x0A;&#x0A;&#x09;/* Disable all RX interrupts before RxBD space setup */&#x0A;&#x0A;&#x09;XAxiDma_BdRingIntDisable(RxRingPtr, XAXIDMA_IRQ_ALL_MASK);&#x0A;&#x0A;&#x09;/* Set delay and coalescing */&#x0A;&#x09;XAxiDma_BdRingSetCoalesce(RxRingPtr, Coalesce, Delay);&#x0A;&#x0A;&#x09;/* Setup Rx BD space */&#x0A;&#x09;BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,&#x0A;&#x09;&#x09;&#x09;&#x09;RX_BD_SPACE_HIGH - RX_BD_SPACE_BASE + 1);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingCreate(RxRingPtr, RX_BD_SPACE_BASE,&#x0A;&#x09;&#x09;&#x09;&#x09;RX_BD_SPACE_BASE,&#x0A;&#x09;&#x09;&#x09;&#x09;XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);&#x0A;&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;RX create BD ring failed %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/*&#x0A;&#x09; * Setup an all-zero BD as the template for the Rx channel.&#x0A;&#x09; */&#x0A;&#x09;XAxiDma_BdClear(&amp;BdTemplate);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingClone(RxRingPtr, &amp;BdTemplate);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;RX clone BD failed %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Attach buffers to RxBD ring so we are ready to receive packets */&#x0A;&#x0A;&#x09;FreeBdCount = XAxiDma_BdRingGetFreeCnt(RxRingPtr);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingAlloc(RxRingPtr, FreeBdCount, &amp;BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;RX alloc BD failed %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;BdCurPtr = BdPtr;&#x0A;&#x09;RxBufferPtr = RX_BUFFER_BASE;&#x0A;&#x09;for (Index = 0; Index &lt; FreeBdCount; Index++) {&#x0A;&#x09;&#x09;Status = XAxiDma_BdSetBufAddr(BdCurPtr, RxBufferPtr);&#x0A;&#x0A;&#x09;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;&#x09;xil_printf(&quot;Set buffer addr %x on BD %x failed %d\r\n&quot;,&#x0A;&#x09;&#x09;&#x09;    (unsigned int)RxBufferPtr,&#x0A;&#x09;&#x09;&#x09;    (UINTPTR)BdCurPtr, Status);&#x0A;&#x0A;&#x09;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;Status = XAxiDma_BdSetLength(BdCurPtr, MAX_PKT_LEN,&#x0A;&#x09;&#x09;&#x09;&#x09;RxRingPtr-&gt;MaxTransferLen);&#x0A;&#x09;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;&#x09;xil_printf(&quot;Rx set length %d on BD %x failed %d\r\n&quot;,&#x0A;&#x09;&#x09;&#x09;    MAX_PKT_LEN, (UINTPTR)BdCurPtr, Status);&#x0A;&#x0A;&#x09;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;/* Receive BDs do not need to set anything for the control&#x0A;&#x09;&#x09; * The hardware will set the SOF/EOF bits per stream status&#x0A;&#x09;&#x09; */&#x0A;&#x09;&#x09;XAxiDma_BdSetCtrl(BdCurPtr, 0);&#x0A;&#x09;&#x09;XAxiDma_BdSetId(BdCurPtr, RxBufferPtr);&#x0A;&#x0A;&#x09;&#x09;RxBufferPtr += MAX_PKT_LEN;&#x0A;&#x09;&#x09;BdCurPtr = (XAxiDma_Bd *)XAxiDma_BdRingNext(RxRingPtr, BdCurPtr);&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Clear the receive buffer, so we can verify data&#x0A;&#x09; */&#x0A;&#x09;memset((void *)RX_BUFFER_BASE, 0, MAX_PKT_LEN);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingToHw(RxRingPtr, FreeBdCount,&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;RX submit hw failed %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Start RX DMA channel */&#x0A;&#x09;Status = XAxiDma_BdRingStart(RxRingPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;RX start hw failed %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;&#x0A;/*****************************************************************************/&#x0A;/**&#x0A;*&#x0A;* This function sets up the TX channel of a DMA engine to be ready for packet&#x0A;* transmission&#x0A;*&#x0A;* @param&#x09;AxiDmaInstPtr is the instance pointer to the DMA engine.&#x0A;*&#x0A;* @return&#x09;XST_SUCCESS if the setup is successful, XST_FAILURE otherwise.&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static int TxSetup(XAxiDma * AxiDmaInstPtr)&#x0A;{&#x0A;&#x09;XAxiDma_BdRing *TxRingPtr;&#x0A;&#x09;XAxiDma_Bd BdTemplate;&#x0A;&#x09;int Delay = 0;&#x0A;&#x09;int Coalesce = 1;&#x0A;&#x09;int Status;&#x0A;&#x09;u32 BdCount;&#x0A;&#x0A;&#x09;TxRingPtr = XAxiDma_GetTxRing(&amp;AxiDma);&#x0A;&#x0A;&#x09;/* Disable all TX interrupts before TxBD space setup */&#x0A;&#x0A;&#x09;XAxiDma_BdRingIntDisable(TxRingPtr, XAXIDMA_IRQ_ALL_MASK);&#x0A;&#x0A;&#x09;/* Set TX delay and coalesce */&#x0A;&#x09;XAxiDma_BdRingSetCoalesce(TxRingPtr, Coalesce, Delay);&#x0A;&#x0A;&#x09;/* Setup TxBD space  */&#x0A;&#x09;BdCount = XAxiDma_BdRingCntCalc(XAXIDMA_BD_MINIMUM_ALIGNMENT,&#x0A;&#x09;&#x09;&#x09;&#x09;TX_BD_SPACE_HIGH - TX_BD_SPACE_BASE + 1);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingCreate(TxRingPtr, TX_BD_SPACE_BASE,&#x0A;&#x09;&#x09;&#x09;&#x09;TX_BD_SPACE_BASE,&#x0A;&#x09;&#x09;&#x09;&#x09;XAXIDMA_BD_MINIMUM_ALIGNMENT, BdCount);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;failed create BD ring in txsetup\r\n&quot;);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/*&#x0A;&#x09; * We create an all-zero BD as the template.&#x0A;&#x09; */&#x0A;&#x09;XAxiDma_BdClear(&amp;BdTemplate);&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingClone(TxRingPtr, &amp;BdTemplate);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;failed bdring clone in txsetup %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Start the TX channel */&#x0A;&#x09;Status = XAxiDma_BdRingStart(TxRingPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;failed start bdring txsetup %d\r\n&quot;, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;&#x0A;/*****************************************************************************/&#x0A;/**&#x0A;*&#x0A;* This function transmits one packet non-blockingly through the DMA engine.&#x0A;*&#x0A;* @param&#x09;AxiDmaInstPtr points to the DMA engine instance&#x0A;*&#x0A;* @return&#x09;- XST_SUCCESS if the DMA accepts the packet successfully,&#x0A;*&#x09;&#x09;- XST_FAILURE otherwise.&#x0A;*&#x0A;* @note     None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static int SendPacket(XAxiDma * AxiDmaInstPtr)&#x0A;{&#x0A;&#x09;XAxiDma_BdRing *TxRingPtr;&#x0A;&#x09;u8 *TxPacket;&#x0A;&#x09;u8 Value;&#x0A;&#x09;XAxiDma_Bd *BdPtr;&#x0A;&#x09;int Status;&#x0A;&#x09;int Index;&#x0A;&#x0A;&#x09;TxRingPtr = XAxiDma_GetTxRing(AxiDmaInstPtr);&#x0A;&#x0A;&#x09;/* Create pattern in the packet to transmit */&#x0A;&#x09;TxPacket = (u8 *) Packet;&#x0A;&#x0A;&#x09;Value = TEST_START_VALUE;&#x0A;&#x0A;&#x09;for(Index = 0; Index &lt; MAX_PKT_LEN; Index ++) {&#x0A;&#x09;&#x09;TxPacket[Index] = Value;&#x0A;&#x0A;&#x09;&#x09;Value = (Value + 1) &amp; 0xFF;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Flush the buffers before the DMA transfer, in case the Data Cache&#x0A;&#x09; * is enabled&#x0A;&#x09; */&#x0A;&#x09;Xil_DCacheFlushRange((UINTPTR)TxPacket, MAX_PKT_LEN);&#x0A;&#x09;Xil_DCacheFlushRange((UINTPTR)RX_BUFFER_BASE, MAX_PKT_LEN);&#x0A;&#x0A;&#x09;/* Allocate a BD */&#x0A;&#x09;Status = XAxiDma_BdRingAlloc(TxRingPtr, 1, &amp;BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Set up the BD using the information of the packet to transmit */&#x0A;&#x09;Status = XAxiDma_BdSetBufAddr(BdPtr, (UINTPTR) Packet);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Tx set buffer addr %x on BD %x failed %d\r\n&quot;,&#x0A;&#x09;&#x09;    (UINTPTR)Packet, (UINTPTR)BdPtr, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;Status = XAxiDma_BdSetLength(BdPtr, MAX_PKT_LEN,&#x0A;&#x09;&#x09;&#x09;&#x09;TxRingPtr-&gt;MaxTransferLen);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Tx set length %d on BD %x failed %d\r\n&quot;,&#x0A;&#x09;&#x09;    MAX_PKT_LEN, (UINTPTR)BdPtr, Status);&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;#if (XPAR_AXIDMA_0_SG_INCLUDE_STSCNTRL_STRM == 1)&#x0A;&#x09;Status = XAxiDma_BdSetAppWord(BdPtr,&#x0A;&#x09;    XAXIDMA_LAST_APPWORD, MAX_PKT_LEN);&#x0A;&#x0A;&#x09;/* If Set app length failed, it is not fatal&#x0A;&#x09; */&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Set app word failed with %d\r\n&quot;, Status);&#x0A;&#x09;}&#x0A;#endif&#x0A;&#x0A;&#x09;/* For single packet, both SOF and EOF are to be set&#x0A;&#x09; */&#x0A;&#x09;XAxiDma_BdSetCtrl(BdPtr, XAXIDMA_BD_CTRL_TXEOF_MASK |&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;XAXIDMA_BD_CTRL_TXSOF_MASK);&#x0A;&#x0A;&#x09;XAxiDma_BdSetId(BdPtr, (UINTPTR)Packet);&#x0A;&#x0A;&#x09;/* Give the BD to DMA to kick off the transmission. */&#x0A;&#x09;Status = XAxiDma_BdRingToHw(TxRingPtr, 1, BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;to hw failed %d\r\n&quot;, Status);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;&#x0A;/*****************************************************************************/&#x0A;/*&#x0A;*&#x0A;* This function checks data buffer after the DMA transfer is finished.&#x0A;*&#x0A;* @param&#x09;None&#x0A;*&#x0A;* @return&#x09;- XST_SUCCESS if validation is successful&#x0A;*&#x09;&#x09;- XST_FAILURE if validation is failure.&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static int CheckData(void)&#x0A;{&#x0A;&#x09;u8 *RxPacket;&#x0A;&#x09;int Index = 0;&#x0A;&#x09;u8 Value;&#x0A;&#x0A;&#x0A;&#x09;RxPacket = (u8 *) RX_BUFFER_BASE;&#x0A;&#x09;Value = TEST_START_VALUE;&#x0A;&#x0A;&#x09;/* Invalidate the DestBuffer before receiving the data, in case the&#x0A;&#x09; * Data Cache is enabled&#x0A;&#x09; */&#x0A;&#x09;Xil_DCacheInvalidateRange((UINTPTR)RxPacket, MAX_PKT_LEN);&#x0A;&#x0A;&#x09;for(Index = 0; Index &lt; MAX_PKT_LEN; Index++) {&#x0A;&#x09;&#x09;if (RxPacket[Index] != Value) {&#x0A;&#x09;&#x09;&#x09;xil_printf(&quot;Data error %d: %x/%x\r\n&quot;,&#x0A;&#x09;&#x09;&#x09;    Index, (unsigned int)RxPacket[Index],&#x0A;&#x09;&#x09;&#x09;    (unsigned int)Value);&#x0A;&#x0A;&#x09;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;Value = (Value + 1) &amp; 0xFF;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;&#x0A;/*****************************************************************************/&#x0A;/**&#x0A;*&#x0A;* This function waits until the DMA transaction is finished, checks data,&#x0A;* and cleans up.&#x0A;*&#x0A;* @param&#x09;None&#x0A;*&#x0A;* @return&#x09;- XST_SUCCESS if DMA transfer is successful and data is correct,&#x0A;*&#x09;&#x09;- XST_FAILURE if fails.&#x0A;*&#x0A;* @note&#x09;&#x09;None.&#x0A;*&#x0A;******************************************************************************/&#x0A;static int CheckDmaResult(XAxiDma * AxiDmaInstPtr)&#x0A;{&#x0A;&#x09;XAxiDma_BdRing *TxRingPtr;&#x0A;&#x09;XAxiDma_BdRing *RxRingPtr;&#x0A;&#x09;XAxiDma_Bd *BdPtr;&#x0A;&#x09;int ProcessedBdCount;&#x0A;&#x09;int FreeBdCount;&#x0A;&#x09;int Status;&#x0A;&#x0A;&#x09;TxRingPtr = XAxiDma_GetTxRing(AxiDmaInstPtr);&#x0A;&#x09;RxRingPtr = XAxiDma_GetRxRing(AxiDmaInstPtr);&#x0A;&#x0A;&#x09;/* Wait until the one BD TX transaction is done */&#x0A;&#x09;while ((ProcessedBdCount = XAxiDma_BdRingFromHw(TxRingPtr,&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;       XAXIDMA_ALL_BDS,&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;       &amp;BdPtr)) == 0) {&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Free all processed TX BDs for future transmission */&#x0A;&#x09;Status = XAxiDma_BdRingFree(TxRingPtr, ProcessedBdCount, BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Failed to free %d tx BDs %d\r\n&quot;,&#x0A;&#x09;&#x09;    ProcessedBdCount, Status);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Wait until the data has been received by the Rx channel */&#x0A;&#x09;while ((ProcessedBdCount = XAxiDma_BdRingFromHw(RxRingPtr,&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;       XAXIDMA_ALL_BDS,&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;       &amp;BdPtr)) == 0) {&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Check received data */&#x0A;&#x09;if (CheckData() != XST_SUCCESS) {&#x0A;&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Free all processed RX BDs for future transmission */&#x0A;&#x09;Status = XAxiDma_BdRingFree(RxRingPtr, ProcessedBdCount, BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Failed to free %d rx BDs %d\r\n&quot;,&#x0A;&#x09;&#x09;    ProcessedBdCount, Status);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/* Return processed BDs to RX channel so we are ready to receive new&#x0A;&#x09; * packets:&#x0A;&#x09; *    - Allocate all free RX BDs&#x0A;&#x09; *    - Pass the BDs to RX channel&#x0A;&#x09; */&#x0A;&#x09;FreeBdCount = XAxiDma_BdRingGetFreeCnt(RxRingPtr);&#x0A;&#x09;Status = XAxiDma_BdRingAlloc(RxRingPtr, FreeBdCount, &amp;BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;bd alloc failed\r\n&quot;);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;Status = XAxiDma_BdRingToHw(RxRingPtr, FreeBdCount, BdPtr);&#x0A;&#x09;if (Status != XST_SUCCESS) {&#x0A;&#x09;&#x09;xil_printf(&quot;Submit %d rx BDs failed %d\r\n&quot;, FreeBdCount, Status);&#x0A;&#x09;&#x09;return XST_FAILURE;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;return XST_SUCCESS;&#x0A;}&#x0A;"/>
			<item value="WriteImage"/>
			<item value="Bitmap"/>
			<item value="assert"/>
			<item value="printf"/>
			<item value="\r"/>
			<item value="read_value"/>
		</list>
		<list key="replacehistory">
			<item value="print_value"/>
		</list>
	</section>
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog_dialogBounds">
		<item value="284" key="DIALOG_WIDTH"/>
		<item value="1|Segoe UI|9.0|0|WINDOWS|1|-12|0|0|0|400|0|0|0|1|0|0|0|0|Segoe UI" key="DIALOG_FONT_NAME"/>
		<item value="391" key="DIALOG_HEIGHT"/>
		<item value="1443" key="DIALOG_X_ORIGIN"/>
		<item value="275" key="DIALOG_Y_ORIGIN"/>
	</section>
</section>
